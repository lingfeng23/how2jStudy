## 分布式和集群

### 单体架构例子(product-service) DONE
- 项目很简单，就做两件事： 1. 提供数据 2. 展示数据。 这就是一个典型的单体结构。

  它把两个服务"提供数据"和"展示数据"放在了一起，这就会出现固有的缺点。
    - 如果要修改数据部分的代码， 那么必须把整个项目重新编译打包部署。 虽然展示部分，什么都没变但是也会因为重新部署而暂时不能使用，要部署完了，才能使用。
    - 如果提供数据部分出现了问题，比如有的开发人员改错了，抛出了异常，会导致整个项目不能使用，展示数据部分也因此受到影响。
    - 性能瓶颈难以突破
    - 等等。。。

### 分布式和集群 DONE

#### 微服务概念
微服务简单说，一个 springboot 就是一个 微服务，并且这个 springboot 做的事情很单纯。 

比如 product-service 这个项目，就可以拆成两个微服务，分别是"数据微服务"和"视图微服务"，其实就是俩 springboot, 只是各自做的事情都更单纯。

#### 服务注册
有了微服务，就存在如何管理这个微服务，以及这两个微服务之间如何通信的问题，所以就要引入一个"微服务注册中心"概念，这个微服务注册中心在 springcloud
里就叫做 eureka server, 通过它把就可以把微服务注册起来，以供将来调用。

#### 服务访问
在业务逻辑上，"视图微服务"需要"数据微服务"的数据，所以就存在一个微服务访问另一个微服务的需要。

而这俩微服务已经被注册中心管理起来了，所以"视图微服务"就可以通过"注册中心"定位并访问"数据微服务"了。

#### 分布式概念
在一个 springboot 里就完成的事情，现在分布在多个 springboot 里做。
- 如果我要更新数据微服务，视图微服务是不受影响的
- 可以让不同的团队开发不同的微服务，他们之间只要约定好接口，彼此之间是低耦合的。
- 如果视图微服务挂了，数据微服务依然可以继续使用 

#### 集群
原来数据微服务只有这一个springboot, 现在做同样数据微服务的有两个 springboot, 他们提供的功能一模一样，只是端口不一样，这样就形成了集群。
- 比起一个 springboot, 两个 springboot 可以分别部署在两个不同的机器上，那么理论上来说，能够承受的负载就是 x 2. 这样系统就具备通过横向扩展而
提高性能的机制。
- 如果 8001 挂了，还有 8002 继续提供微服务，这就叫做高可用 。

#### 分布式和集群周边服务
- 哪些微服务是如何彼此调用的？ sleuth 服务链路追踪
- 如何在微服务间共享配置信息？配置服务 Config Server
- 如何让配置信息在多个微服务之间自动刷新？ RabbitMQ 总线 Bus
- 如果数据微服务集群都不能使用了，视图微服务如何去处理? 断路器 Hystrix
- 视图微服务的断路器什么时候开启了？什么时候关闭了？ 断路器监控 Hystrix Dashboard
- 如果视图微服务本身是个集群，那么如何对他们进行聚合监控？ 断路器聚合监控 Turbine Hystrix Dashboard
- 如何不暴露微服务名称，并提供服务？ Zuul 网关

### 父子项目 DONE

### 服务注册中心 DONE